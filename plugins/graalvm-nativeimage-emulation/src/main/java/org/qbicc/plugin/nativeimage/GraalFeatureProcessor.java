package org.qbicc.plugin.nativeimage;

import com.oracle.svm.core.BuildPhaseProvider;
import com.oracle.svm.core.configure.ResourcesRegistry;
import com.oracle.svm.core.jdk.Resources;
import com.oracle.svm.core.jdk.localization.LocalizationFeature;
import com.oracle.svm.core.jdk.localization.LocalizationSupport;
import org.graalvm.nativeimage.hosted.Feature;
import org.graalvm.nativeimage.impl.RuntimeClassInitializationSupport;
import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;
import org.qbicc.context.CompilationContext;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;

public class GraalFeatureProcessor {
    public static void process(CompilationContext ctxt, List<String> features, ClassLoader cl) {
        if (features.isEmpty()) {
            return;
        }

        // Fake up enough of the GraalVM Support classes to let us execute the
        // Feature lifecycle methods that are generated by Quarkus and perform
        // the corresponding actions for qbicc.
        QbiccImageSingletonsSupport qiss = new QbiccImageSingletonsSupport();
        QbiccRuntimeReflectionSupport qrrs = new QbiccRuntimeReflectionSupport(ctxt);
        qiss.add(RuntimeReflectionSupport.class, qrrs);
        qiss.add(RuntimeClassInitializationSupport.class, new QbiccRuntimeClassInitializationSupport(ctxt));
        qiss.add(ResourcesRegistry.class, new QbiccResourcesRegistry(ctxt));
        qiss.add(LocalizationSupport.class, new QbiccLocalizationSupport(Locale.getDefault(), Set.of(), Charset.defaultCharset()));
        qiss.add(LocalizationFeature.class, new QbiccLocalizationFeature());
        try {
            Class<BuildPhaseProvider> buildPhaseProviderClass = (Class<BuildPhaseProvider>)Class.forName("com.oracle.svm.core.BuildPhaseProvider");
            Constructor<BuildPhaseProvider> bc = buildPhaseProviderClass.getDeclaredConstructor();
            bc.setAccessible(true);
            BuildPhaseProvider buildPhaseProviderInstance = bc.newInstance();
            qiss.add(BuildPhaseProvider.class, buildPhaseProviderInstance);
        } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
            ctxt.error("Unable to instantiate com.oracle.svm.core.BuildPhaseProvider");
            return;
        }
        try {
            Class<Resources> resourcesClass = (Class<Resources>)Class.forName("com.oracle.svm.core.jdk.Resources");
            Constructor<Resources> rc = resourcesClass.getDeclaredConstructor();
            rc.setAccessible(true);
            Resources resourcesInstance = rc.newInstance();
            qiss.add(Resources.class, resourcesInstance);
        } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
            ctxt.error("Unable to instantiate com.oracle.svm.core.jdk.Resources");
            return;
        }

        // Set up the current Thread to load application classes into the hostVM via its CCL
        ClassLoader savedCCL = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(cl);

            // Instantiate the Features (and their transitively required Features)
            ArrayList<Feature> featureInstances = new ArrayList<>();
            for (String feature : features) {
                Class<Feature> featureClass;
                try {
                    featureClass = (Class<Feature>) cl.loadClass(feature);
                } catch (ClassNotFoundException e) {
                    ctxt.error("Failed to load feature %s", feature);
                    continue;
                }
                instantiateFeature(featureClass, featureInstances, ctxt);
            }

            // Invoke the life cycle methods on each featureInstance
            Feature.DuringSetupAccess dsa = new QbiccDuringSetupAccess(ctxt);
            for (Feature f: featureInstances) {
                try {
                    ctxt.info("Invoking duringSetup() on %s", f.getClass().getName());
                    f.duringSetup(dsa);
                } catch (Exception e) {
                    ctxt.error(e, "Exception while executing %s.duringSetup", f.getClass().getName());
                }
            }

            Feature.BeforeAnalysisAccess baa = new QbiccBeforeAnalysisAccess(ctxt, qrrs);
            for (Feature f: featureInstances) {
                try {
                    ctxt.info("Invoking beforeAnalysis() on %s", f.getClass().getName());
                    f.beforeAnalysis(baa);
                } catch (Exception e) {
                    ctxt.error(e, "Exception while executing %s.beforeAnalysis", f.getClass().getName());
                }
            }
        } finally {
            Thread.currentThread().setContextClassLoader(savedCCL);
        }

        // Finally, commit the registered classes/fields/methods by mapping from host JVM
        // Class/Method/Field objects to qbicc LoadedTypes.
        qrrs.processRegistrations();
    }

    private static void instantiateFeature(Class<? extends Feature> featureClass, ArrayList<Feature> instances, CompilationContext ctxt) {
        if (instances.stream().anyMatch(f -> f.getClass().equals(featureClass))) {
            return; // Already in our list of instantiated features
        }

        try {
            Feature featureInstance = featureClass.getDeclaredConstructor().newInstance();
            for (Class<? extends Feature> rf: featureInstance.getRequiredFeatures()) {
                instantiateFeature(rf, instances, ctxt);
            }
            instances.add(featureInstance);
        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
            ctxt.error("Failed to instantiate feature %s", featureClass.getName());
        }
    }
}
